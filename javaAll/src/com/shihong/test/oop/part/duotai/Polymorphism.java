package com.shihong.test.oop.part.duotai;

/**
 * @author shihong on 2020/8/31.
 *         多态
 */
public class Polymorphism {

	/*
	*	1，面向对象特征之三：多态性
	*
	*	2，多态 的好处：
			重用性好，简单方便 可维护

		3，多态性，是面向对象中最重要的概念，在java中有两种体现：
			1.方法的重载(overload)和重写(overwrite)。
			2.对象的多态性	———— 可以直接应用在抽象类和接口上。

		4，Java引用变量有两个类型：编译时类型和运行时类型。
			编译时类型由声明该变量时使用的类型决定，
			运行时类型由实际赋给该变量的对象决定。
			若编译时类型和运行时类型不一致，就出现多态（Polymorphism）

		5，对象的多态：在Java中,子类的对象可以替代父类的对象使用
			（子类的对象实例指向父类的引用）

		6，对象的多态 —在Java中,子类的对象可以替代父类的对象使用
			a) 一个变量只能有一种确定的数据类型
			b) 一个引用类型变量可能指向(引用)多种不同类型的对象
			c)	Person p = new Student(); //person类型的变量 p 指向Students类型的对象
			d)	Object o = new Person();//Object类型的变量o，指向Person类型的对象
			e)	o = new Student(); //Object类型的变量o，指向Student类型的对象

		子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向上 转型(upcasting)。

		7，一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不 能再访问子类中添加的属性和方法
			a)	Student m = new Student();
			b)	m.school = “pku”;   //合法,Student类有school成员变量
			c)	Person e = new Student();
			d)	e.school = “pku”;   //非法,Person类没有school成员变量
			b)	属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而编译错 误。

		8，虚拟方法调用(Virtual Method Invocation)
			正常的方法调用：（不存在多态，各自调用自己的方法）
				c)	Person e = new Person();
				d)	e.getInfo();
				e)	Student e = new Student();
				f)	e.getInfo();
			虚拟方法调用(多态情况下)
				h)	Person e = new Student();
				i)	e.getInfo();    //调用Student类的getInfo()方法
				j)	编译时类型和运行时类型
				k) 编译时e为Person类型，而方法的调用是在运行时确定的，所以调用的是Student类的getInfo()方法。
					这种方式就是————动态绑定

		9，虚拟方法调用（动态绑定)
			前提：
				需要存在继承或者实现关系
				要有覆盖操作
			成员方法：
				a) 编译时：要查看引用变量所属的类中是否有所调用的方法。(编译时检查父类类 型)
				b) 运行时：调用实际对象所属的类中的重写方法。
					(运行时执行子类类型)
			成员变量：
				不具备多态性，只看引用变量所属的类。（属性不具 有多态性）
			静态函数
				static修饰的方法，在多态时特性与变量一致，都只看引用类型所属的类
				（个人认为静态函数不具备多态，因为多态指的是对象的多态性，而静态函数是属 于类的函数）

		10，子类继承父类
        	若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类 里的方法转移到子类中
			对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不
			可能覆盖父类中定义的实例变量（实例变量指的是类中的属性）（属性不具有多态性）
			子类和父类可以同时拥有同名的实例变量，子类的值并未将父类的值覆盖掉，而若是有同名的方法的时候，子类的方法会把父类的方
			法覆盖掉，所以：
			父类 对象 = new 子类（）; 的时候：
			对象.属性 ----》 调用的是 父类的
			对象.方法 ----》 调用的是 子类的

		11，多态数组
			特点：
				数组的定义类型为父类类型，数组元素的实际类型为子类类型
			使用：
				和普通数组的使用步骤一样

		12，多态参数
			特点：
				方法的形参类型为父类类型，实参类型为子类类型
			使用：
				和方法的普通参数使用一致

		13，多态的前提：要有继承关系 ，有方法的重写（为了完成虚拟方法调用）

		14，Java的运行分为两种状态，在多态的情况下：
			编译时：“看左边”，看到的是父类的引用（父类中没有子类特有的方法）
			运行时：“看右边”，看到的是子类的对象,实际运行的是子类重写父类的方法
			（这就是虚拟方法调用，即动态绑定）


	*/

}
