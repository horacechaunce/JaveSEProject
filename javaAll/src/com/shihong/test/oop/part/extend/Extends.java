package com.shihong.test.oop.part.extend;

/**
 * @author shihong on 2020/8/28.
 * 继承
 */
public class Extends {
	/*
	 * 继承
	 * 		为什么要有继承？
	 * 			多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类 无需再定义这些属性和行为，只要继承那个类即可。
	 *
	 * 		此处的多个类称为子类，单独的这个类称为父类（基类或超类）。可以理解为:“子类 is a 父类”
	 *		类继承语法规则:
	 *			class Subclass extends Superclass{ }
	 *
	 *		子类继承了父类，就继承了父类的方法和属性
	 *		在子类中，自动拥有父类中定义的方法和属性，也可以创建新的数据和方法。
	 *		在Java 中，继承的关键字用的是“extends”，即子类不是父类的子集，而是对父类的“扩展”。
	 *
	 *	注：继承的内容不包括构造器
	 *
	 * 	子类继承父类的属性和方法，父类中定义好了属性和方法，子类不用重写
	 *
	 * 	好处：
	 * 		实现了代码的重用
	 * 		为后面的多态打下了基础
	 * 		利于维护
	 *
	 * 	继承 的概念：
	 * 		被继承的类称为父类（基类，超类），继承其他 类的类称为子类（派生类）
	 * 		子类可以继承父类 的所有的属性和方法
	 *
	 *	继承的特点：
	 *		子类继承的属性和方法包含私有的 ， 只是私有的不能直接使用 要通过公有的set 和 get 方法来使用
	 *		通过 extends关键字表示继承关系，子类不是父类 的子集，可以扩展（指可以 有自 己特有的方法和属性）
	 *		一个类只能继承一个直接父类，java支持单继承
	 *		在java中所有的类都直接或间接继承Object类;  ctrl +	Ｔ	查看继承关系
	 *
	 *	子类不能继承父类 的构造方法，但是必须 调用父类 的构造方法;
	 *		如果子类没有显式调用父类 的构造方法，相当于默认调用父类 的无参构造
	 *		如果父类没有无参构造，必须显式调用父类有参构造，否则会报错
	 *	 	如果 显式的调用父类 的其他 构造方法，只需要直接调用就可以；
	 *	 	语法为：在子类的构造方法中利用super关键字调用
	 *
	 *	 Super 关键字：
			 a) 显式调用父类 的有参的构造器  Super(父类参数列表);
			 b) 用来调用父类的方法和属性
			 c) 用于在子类的方法中调用父类 的构造器
	  		 d) 它是父类的一个引用
			 e) 当父类 没有无参构造时，子类想显式调用父类 有参构造时，必须添加 super关键字调用
			 f) 当父类和子类中有重名的属性或方法时，我们想区分开，可以使用super关键字
			 g) 代表的是当前类的父类 引用，可以调用父类的属性方法和构造    父类被private修饰 的私有属性，必须通过get和set方法使用

	 	语法：
	 		Super.属性 = 值
	 		Super.方法名（）；
	 		调用构造 ： super（参数列表 ）;

		 super调用构造器的特点：
			 a) 只能放在子类构造方法的首行
			 b) This()和super()方法不能同时出现

		 protected 修饰的属性和方法   在其他 包的子类能访问是指直接使用，不能用对象调用


	 	super 关键字： 和 this 使用方式一模一样
	 		this ： 使用在本类中，代表当前对象引用
			super: 使用在子类中，代表父类对象引用
	 		①当子类继承父类后，子类“所有”构造器第一行第一句有一个隐式的super();
			super() 调用父类无参构造器，当子类继承父类，子类要知道父类如何为对象初始化
	 		②若父类没有提供无参构造器，子类的所有构造器首行都要显示的调用父类的有参构造器
	 		③super() 和 this()都必须放在构造器可执行代码的首行，因此二者不能同时出现

	 */

	/*
	 * 1，子类和父类的关系是 is a 的关系 （所属关系）
	 * 2，java只提供单继承，但可以多层继承
	 *
	 *
	 * 　1.子类继承父类的成员变量
	 *
	 *　　当子类继承了某个类之后，便可以使用父类中的成员变量，但是并不是完全继承父类的所有成员变量。具体的原则如下：

	 *　 1）能够继承父类的public和protected成员变量；不能够继承父类的private成员变量；

	 　　2）对于父类的包访问权限成员变量，如果子类和父类在同一个包下，则子类能够继承；否则，子类不能够继承；

	 　　3）对于子类可以继承的父类成员变量，如果在子类中出现了同名称的成员变量，则会发生隐藏现象，
	 		即子类的成员变量会屏蔽掉父类的同名成员变量。如果要在子类中访问父类中同名成员变量，
	 		需要使用super关键字来进行引用。

	 　　2.子类继承父类的方法

	 　　同样地，子类也并不是完全继承父类的所有方法。

	 　　1）能够继承父类的public和protected成员方法；不能够继承父类的private成员方法；

	 　　2）对于父类的包访问权限成员方法，如果子类和父类在同一个包下，则子类能够继承；否则，子类不能够继承；

	 　　3）对于子类可以继承的父类成员方法，如果在子类中出现了同名称的成员方法，则称为覆盖，
	 		即子类的成员方法会覆盖掉父类的同名成员方法。如果要在子类中访问父类中同名成员方法，
	 		需要使用super关键字来进行引用。

	 　　注意：隐藏和覆盖是不同的。隐藏是针对成员变量和静态方法的，而覆盖是针对普通方法的。
	 */

	/*
	 * 重载和重写的区别
	 *
	 方法的重写规则
		 参数列表必须完全与被重写方法的相同；
		 返回类型必须完全与被重写方法的返回类型相同；
		 访问权限不能比父类中被重写的方法的访问权限更低。
			例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。
		 父类的成员方法只能被它的子类重写。
		 声明为final的方法不能被重写。
		 声明为static的方法不能被重写，但是能够被再次声明。
		 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。
		 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。
		 重写的方法能够抛出任何非强制异常，子类抛出的异常范围必须大于等于父类抛出的异常范围
		 构造方法不能被重写。
		 如果不能继承一个方法，则不能重写这个方法。

	 重载(Overload)
	 重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。
	 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。

	 重载规则
		 被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)；
		 被重载的方法可以改变返回类型；
		 被重载的方法可以改变访问修饰符；
		 被重载的方法可以声明新的或更广的检查异常；
		 方法能够在同一个类中或者在一个子类中被重载。
		 无法以返回值类型作为重载函数的区分标准
	 */



/*
 以下是一个练习题 ，考点是继承时对象初始化过程，运行结果是
    shape draw constructor
    shape constructor
    circle draw constructor
    circle constructor
 出现这样的结果是因为在执行过程中，如下面标注的数字顺序


class Test {

    public static void main(String[] args)  {
        new Circle(); //开始调用 1
        //在对象调用后，在内存开辟空间，对属性先默认初始化，
        //然后执行父类的构造函数结束后，再对子类的属性显示初始化
    }
}

class Draw {

    public Draw(String type) {
        super(); //调用父类无参 5  再次被调用 10
        System.out.println(type+" draw constructor"); // 输出  6 输出 11
    }
}

class Shape {
    private Draw draw = new Draw("shape"); //初始化成员,调用Draw(type) 4
    private String s = null;   // 初始化成员 ， 7

    public Shape(){
        super(); //无参构造运行后，初始化父类的变量再初始化它的成员 3   第7步完成后返回到这里
        System.out.println("shape constructor"); //输出  8
    }
}

class Circle extends Shape {
    private Draw draw = new Draw("circle"); //加载成员，调用new Draw("circle")  9  调用完成后返回这里继续

    public Circle() {
        super();  //先运行它的父类无参构造 2  第8步完成后返回到这里后加载这个类的成员
        System.out.println("circle constructor");  //输出 12
    }
}
*/
}
